---
title: Authentication Example
description: Complete authentication module implementation using Modular Flutter
---

This example demonstrates how to build a complete authentication module using the Modular Flutter architecture, including login, registration, and session management.

## Module Structure

```
lib/modules/auth/
├── models/
│   ├── user_model.dart
│   ├── auth_state_model.dart
│   └── login_request.dart
├── providers/
│   └── auth_providers.dart
├── repositories/
│   ├── auth_repository.dart
│   └── auth_repository_impl.dart
├── screens/
│   ├── login_screen.dart
│   ├── register_screen.dart
│   └── forgot_password_screen.dart
├── services/
│   └── auth_service.dart
├── states/
│   ├── login_state.dart
│   └── register_state.dart
├── viewmodels/
│   ├── login_viewmodel.dart
│   └── register_viewmodel.dart
├── widgets/
│   └── auth_form_field.dart
├── auth_module.dart
└── auth_router.dart
```

## Models

### User Model

```dart
// lib/modules/auth/models/user_model.dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'user_model.freezed.dart';
part 'user_model.g.dart';

@freezed
class User with _$User {
  const factory User({
    required String id,
    required String email,
    required String name,
    String? avatarUrl,
    @Default([]) List<String> roles,
    required DateTime createdAt,
    DateTime? lastLoginAt,
    @Default(false) bool isEmailVerified,
  }) = _User;

  const User._();

  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);

  bool hasRole(String role) => roles.contains(role);

  bool get isAdmin => hasRole('admin');

  String get displayName => name.isNotEmpty ? name : email;
}

@freezed
class AuthState with _$AuthState {
  const factory AuthState({
    User? user,
    String? accessToken,
    String? refreshToken,
    DateTime? expiresAt,
    @Default(false) bool isAuthenticated,
  }) = _AuthState;

  const AuthState._();

  factory AuthState.fromJson(Map<String, dynamic> json) =>
      _$AuthStateFromJson(json);

  bool get isTokenExpired =>
      expiresAt?.isBefore(DateTime.now()) ?? false;

  bool get needsRefresh =>
      isAuthenticated && (isTokenExpired ||
      (expiresAt?.difference(DateTime.now()).inMinutes ?? 0) < 5);
}
```

### Request Models

```dart
// lib/modules/auth/models/login_request.dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'login_request.freezed.dart';
part 'login_request.g.dart';

@freezed
class LoginRequest with _$LoginRequest {
  const factory LoginRequest({
    required String email,
    required String password,
    @Default(false) bool rememberMe,
  }) = _LoginRequest;

  factory LoginRequest.fromJson(Map<String, dynamic> json) =>
      _$LoginRequestFromJson(json);
}

@freezed
class RegisterRequest with _$RegisterRequest {
  const factory RegisterRequest({
    required String email,
    required String password,
    required String name,
    String? inviteCode,
  }) = _RegisterRequest;

  factory RegisterRequest.fromJson(Map<String, dynamic> json) =>
      _$RegisterRequestFromJson(json);
}

@freezed
class AuthResponse with _$AuthResponse {
  const factory AuthResponse({
    required User user,
    required String accessToken,
    required String refreshToken,
    required DateTime expiresAt,
  }) = _AuthResponse;

  factory AuthResponse.fromJson(Map<String, dynamic> json) =>
      _$AuthResponseFromJson(json);
}
```

## Service Layer

```dart
// lib/modules/auth/services/auth_service.dart
import 'package:dio/dio.dart';
import '../models/user_model.dart';
import '../models/login_request.dart';

class AuthService {
  final Dio _dio;
  final String _baseUrl;

  AuthService({
    required Dio dio,
    required String baseUrl,
  }) : _dio = dio, _baseUrl = baseUrl;

  Future<AuthResponse> login(LoginRequest request) async {
    try {
      final response = await _dio.post(
        '$_baseUrl/auth/login',
        data: request.toJson(),
      );

      if (response.statusCode == 200) {
        return AuthResponse.fromJson(response.data);
      }

      throw Exception('Login failed');
    } on DioException catch (e) {
      if (e.response?.statusCode == 401) {
        throw Exception('Invalid email or password');
      } else if (e.response?.statusCode == 429) {
        throw Exception('Too many login attempts. Please try again later.');
      }
      throw Exception('Network error: ${e.message}');
    }
  }

  Future<AuthResponse> register(RegisterRequest request) async {
    try {
      final response = await _dio.post(
        '$_baseUrl/auth/register',
        data: request.toJson(),
      );

      if (response.statusCode == 201) {
        return AuthResponse.fromJson(response.data);
      }

      throw Exception('Registration failed');
    } on DioException catch (e) {
      if (e.response?.statusCode == 409) {
        throw Exception('An account with this email already exists');
      } else if (e.response?.statusCode == 422) {
        final errors = e.response?.data['errors'] as Map<String, dynamic>?;
        final errorMessage = errors?.values.first ?? 'Validation failed';
        throw Exception(errorMessage);
      }
      throw Exception('Network error: ${e.message}');
    }
  }

  Future<AuthResponse> refreshToken(String refreshToken) async {
    try {
      final response = await _dio.post(
        '$_baseUrl/auth/refresh',
        data: {'refresh_token': refreshToken},
      );

      if (response.statusCode == 200) {
        return AuthResponse.fromJson(response.data);
      }

      throw Exception('Token refresh failed');
    } on DioException catch (e) {
      if (e.response?.statusCode == 401) {
        throw Exception('Refresh token expired');
      }
      throw Exception('Network error: ${e.message}');
    }
  }

  Future<void> logout(String accessToken) async {
    try {
      await _dio.post(
        '$_baseUrl/auth/logout',
        options: Options(
          headers: {'Authorization': 'Bearer $accessToken'},
        ),
      );
    } on DioException catch (e) {
      // Log error but don't throw - logout should always succeed locally
      print('Logout error: ${e.message}');
    }
  }

  Future<void> forgotPassword(String email) async {
    try {
      final response = await _dio.post(
        '$_baseUrl/auth/forgot-password',
        data: {'email': email},
      );

      if (response.statusCode != 200) {
        throw Exception('Password reset request failed');
      }
    } on DioException catch (e) {
      throw Exception('Network error: ${e.message}');
    }
  }

  Future<User> getCurrentUser(String accessToken) async {
    try {
      final response = await _dio.get(
        '$_baseUrl/auth/me',
        options: Options(
          headers: {'Authorization': 'Bearer $accessToken'},
        ),
      );

      if (response.statusCode == 200) {
        return User.fromJson(response.data);
      }

      throw Exception('Failed to get user profile');
    } on DioException catch (e) {
      throw Exception('Network error: ${e.message}');
    }
  }
}
```

## Repository Implementation

```dart
// lib/modules/auth/repositories/auth_repository.dart
import '../models/user_model.dart';
import '../models/login_request.dart';

abstract class AuthRepository {
  Future<AuthState> login(LoginRequest request);
  Future<AuthState> register(RegisterRequest request);
  Future<void> logout();
  Future<AuthState?> refreshAuth();
  Future<void> forgotPassword(String email);
  Future<AuthState?> getCurrentAuthState();
  Future<void> clearAuthState();
}

// lib/modules/auth/repositories/auth_repository_impl.dart
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import '../models/user_model.dart';
import '../models/login_request.dart';
import '../services/auth_service.dart';
import 'auth_repository.dart';

class AuthRepositoryImpl implements AuthRepository {
  final AuthService _authService;
  final FlutterSecureStorage _secureStorage;

  static const String _authStateKey = 'auth_state';

  AuthRepositoryImpl(this._authService, this._secureStorage);

  @override
  Future<AuthState> login(LoginRequest request) async {
    final response = await _authService.login(request);
    final authState = AuthState(
      user: response.user,
      accessToken: response.accessToken,
      refreshToken: response.refreshToken,
      expiresAt: response.expiresAt,
      isAuthenticated: true,
    );

    await _saveAuthState(authState);
    return authState;
  }

  @override
  Future<AuthState> register(RegisterRequest request) async {
    final response = await _authService.register(request);
    final authState = AuthState(
      user: response.user,
      accessToken: response.accessToken,
      refreshToken: response.refreshToken,
      expiresAt: response.expiresAt,
      isAuthenticated: true,
    );

    await _saveAuthState(authState);
    return authState;
  }

  @override
  Future<void> logout() async {
    final authState = await getCurrentAuthState();
    if (authState?.accessToken != null) {
      await _authService.logout(authState!.accessToken!);
    }
    await clearAuthState();
  }

  @override
  Future<AuthState?> refreshAuth() async {
    final currentAuthState = await getCurrentAuthState();
    if (currentAuthState?.refreshToken == null) {
      return null;
    }

    try {
      final response = await _authService.refreshToken(
        currentAuthState!.refreshToken!,
      );

      final newAuthState = AuthState(
        user: response.user,
        accessToken: response.accessToken,
        refreshToken: response.refreshToken,
        expiresAt: response.expiresAt,
        isAuthenticated: true,
      );

      await _saveAuthState(newAuthState);
      return newAuthState;
    } catch (e) {
      await clearAuthState();
      rethrow;
    }
  }

  @override
  Future<void> forgotPassword(String email) async {
    await _authService.forgotPassword(email);
  }

  @override
  Future<AuthState?> getCurrentAuthState() async {
    try {
      final authStateJson = await _secureStorage.read(key: _authStateKey);
      if (authStateJson == null) return null;

      final authState = AuthState.fromJson(
        Map<String, dynamic>.from(
          jsonDecode(authStateJson),
        ),
      );

      // Check if token is expired
      if (authState.isTokenExpired) {
        await clearAuthState();
        return null;
      }

      return authState;
    } catch (e) {
      await clearAuthState();
      return null;
    }
  }

  @override
  Future<void> clearAuthState() async {
    await _secureStorage.delete(key: _authStateKey);
  }

  Future<void> _saveAuthState(AuthState authState) async {
    await _secureStorage.write(
      key: _authStateKey,
      value: jsonEncode(authState.toJson()),
    );
  }
}
```

## ViewModels

### Login ViewModel

```dart
// lib/modules/auth/states/login_state.dart
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:viewmodel/viewmodel.dart';

part 'login_state.freezed.dart';

@freezed
class LoginState with _$LoginState implements UiState {
  const factory LoginState({
    @Default(UiStatus.initial) UiStatus status,
    @Default('') String email,
    @Default('') String password,
    @Default(false) bool isPasswordVisible,
    @Default(false) bool rememberMe,
    String? emailError,
    String? passwordError,
    String? errorMessage,
  }) = _LoginState;

  const LoginState._();

  bool get isValid =>
      emailError == null &&
      passwordError == null &&
      email.isNotEmpty &&
      password.isNotEmpty;

  LoginState get loading => copyWith(status: UiStatus.loading);

  LoginState success() => copyWith(
    status: UiStatus.success,
    errorMessage: null,
  );

  LoginState error(String message) => copyWith(
    status: UiStatus.error,
    errorMessage: message,
  );
}

// lib/modules/auth/viewmodels/login_viewmodel.dart
import 'package:viewmodel/viewmodel.dart';
import '../models/login_request.dart';
import '../repositories/auth_repository.dart';
import '../states/login_state.dart';

class LoginViewModel extends ViewModel<LoginState> {
  final AuthRepository _authRepository;

  LoginViewModel(this._authRepository) : super(const LoginState());

  void updateEmail(String email) {
    state = state.copyWith(
      email: email,
      emailError: _validateEmail(email),
    );
  }

  void updatePassword(String password) {
    state = state.copyWith(
      password: password,
      passwordError: _validatePassword(password),
    );
  }

  void togglePasswordVisibility() {
    state = state.copyWith(isPasswordVisible: !state.isPasswordVisible);
  }

  void toggleRememberMe() {
    state = state.copyWith(rememberMe: !state.rememberMe);
  }

  Future<void> login() async {
    if (!state.isValid) return;

    try {
      state = state.loading;

      final request = LoginRequest(
        email: state.email.trim(),
        password: state.password,
        rememberMe: state.rememberMe,
      );

      await _authRepository.login(request);
      state = state.success();
    } catch (e) {
      state = state.error(e.toString());
    }
  }

  String? _validateEmail(String email) {
    if (email.isEmpty) return null; // Don't show error for empty field

    final emailRegex = RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$');
    if (!emailRegex.hasMatch(email)) {
      return 'Please enter a valid email address';
    }
    return null;
  }

  String? _validatePassword(String password) {
    if (password.isEmpty) return null; // Don't show error for empty field

    if (password.length < 6) {
      return 'Password must be at least 6 characters';
    }
    return null;
  }
}
```

## UI Screens

### Login Screen

```dart
// lib/modules/auth/screens/login_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import '../providers/auth_providers.dart';
import '../states/login_state.dart';
import '../widgets/auth_form_field.dart';

class LoginScreen extends ConsumerWidget {
  final String? redirectPath;

  const LoginScreen({super.key, this.redirectPath});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(loginViewModelProvider);
    final viewModel = ref.read(loginViewModelProvider.notifier);

    // Listen for successful login
    ref.listen<LoginState>(loginViewModelProvider, (previous, next) {
      if (next.status == UiStatus.success) {
        context.go(redirectPath ?? '/dashboard');
      }
    });

    return Scaffold(
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // Logo and title
              Icon(
                Icons.lock_outline,
                size: 80,
                color: Theme.of(context).primaryColor,
              ),
              const SizedBox(height: 32),
              Text(
                'Welcome Back',
                style: Theme.of(context).textTheme.headlineMedium,
                textAlign: TextAlign.center,
              ),
              Text(
                'Sign in to your account',
                style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                  color: Colors.grey[600],
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 48),

              // Login form
              AuthFormField(
                label: 'Email',
                value: state.email,
                errorText: state.emailError,
                keyboardType: TextInputType.emailAddress,
                textInputAction: TextInputAction.next,
                onChanged: viewModel.updateEmail,
              ),
              const SizedBox(height: 16),

              AuthFormField(
                label: 'Password',
                value: state.password,
                errorText: state.passwordError,
                isPassword: true,
                isPasswordVisible: state.isPasswordVisible,
                textInputAction: TextInputAction.done,
                onChanged: viewModel.updatePassword,
                onTogglePasswordVisibility: viewModel.togglePasswordVisibility,
                onSubmitted: (_) => viewModel.login(),
              ),
              const SizedBox(height: 16),

              // Remember me and forgot password
              Row(
                children: [
                  Checkbox(
                    value: state.rememberMe,
                    onChanged: (_) => viewModel.toggleRememberMe(),
                  ),
                  const Text('Remember me'),
                  const Spacer(),
                  TextButton(
                    onPressed: () => context.push('/auth/forgot-password'),
                    child: const Text('Forgot Password?'),
                  ),
                ],
              ),
              const SizedBox(height: 32),

              // Login button
              ElevatedButton(
                onPressed: state.isValid && state.status != UiStatus.loading
                    ? viewModel.login
                    : null,
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 16),
                ),
                child: state.status == UiStatus.loading
                    ? const SizedBox(
                        height: 20,
                        width: 20,
                        child: CircularProgressIndicator(strokeWidth: 2),
                      )
                    : const Text('Sign In'),
              ),

              // Error message
              if (state.errorMessage != null) ...[
                const SizedBox(height: 16),
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: Colors.red[50],
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(color: Colors.red[200]!),
                  ),
                  child: Text(
                    state.errorMessage!,
                    style: TextStyle(color: Colors.red[700]),
                    textAlign: TextAlign.center,
                  ),
                ),
              ],

              const SizedBox(height: 32),

              // Register link
              Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Text("Don't have an account? "),
                  TextButton(
                    onPressed: () => context.push('/auth/register'),
                    child: const Text('Sign Up'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

### Auth Form Field Widget

```dart
// lib/modules/auth/widgets/auth_form_field.dart
import 'package:flutter/material.dart';

class AuthFormField extends StatelessWidget {
  final String label;
  final String value;
  final String? errorText;
  final bool isPassword;
  final bool isPasswordVisible;
  final TextInputType keyboardType;
  final TextInputAction textInputAction;
  final ValueChanged<String> onChanged;
  final VoidCallback? onTogglePasswordVisibility;
  final ValueChanged<String>? onSubmitted;

  const AuthFormField({
    super.key,
    required this.label,
    required this.value,
    this.errorText,
    this.isPassword = false,
    this.isPasswordVisible = false,
    this.keyboardType = TextInputType.text,
    this.textInputAction = TextInputAction.next,
    required this.onChanged,
    this.onTogglePasswordVisibility,
    this.onSubmitted,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        TextFormField(
          initialValue: value,
          keyboardType: keyboardType,
          textInputAction: textInputAction,
          obscureText: isPassword && !isPasswordVisible,
          onChanged: onChanged,
          onFieldSubmitted: onSubmitted,
          decoration: InputDecoration(
            labelText: label,
            errorText: errorText,
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(8),
            ),
            suffixIcon: isPassword
                ? IconButton(
                    icon: Icon(
                      isPasswordVisible ? Icons.visibility : Icons.visibility_off,
                    ),
                    onPressed: onTogglePasswordVisibility,
                  )
                : null,
          ),
        ),
      ],
    );
  }
}
```

## Providers

```dart
// lib/modules/auth/providers/auth_providers.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:get_it/get_it.dart';
import '../models/user_model.dart';
import '../repositories/auth_repository.dart';
import '../states/login_state.dart';
import '../viewmodels/login_viewmodel.dart';

// Repository provider
final authRepositoryProvider = Provider<AuthRepository>((ref) {
  return GetIt.instance<AuthRepository>();
});

// Auth state provider
final authStateProvider = StreamProvider<AuthState?>((ref) async* {
  final repository = ref.read(authRepositoryProvider);

  // Initial auth state
  yield await repository.getCurrentAuthState();

  // You would typically have a stream here that listens to auth changes
  // For now, we'll just yield the current state
});

// Current user provider
final currentUserProvider = Provider<User?>((ref) {
  final authState = ref.watch(authStateProvider);
  return authState.whenData((state) => state?.user).value;
});

// Authentication status provider
final isAuthenticatedProvider = Provider<bool>((ref) {
  final authState = ref.watch(authStateProvider);
  return authState.whenData((state) => state?.isAuthenticated ?? false).value ?? false;
});

// Login ViewModel provider
final loginViewModelProvider =
    StateNotifierProvider<LoginViewModel, LoginState>((ref) {
  final repository = ref.read(authRepositoryProvider);
  return LoginViewModel(repository);
});

// Register ViewModel provider
final registerViewModelProvider =
    StateNotifierProvider<RegisterViewModel, RegisterState>((ref) {
  final repository = ref.read(authRepositoryProvider);
  return RegisterViewModel(repository);
});
```

## Module Setup

```dart
// lib/modules/auth/auth_module.dart
import 'package:get_it/get_it.dart';
import 'package:modular_core/modular_core.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'repositories/auth_repository.dart';
import 'repositories/auth_repository_impl.dart';
import 'services/auth_service.dart';
import 'auth_router.dart';

class AuthModule extends Module<AuthRouter> {
  @override
  AuthRouter createRouter() => AuthRouter();

  @override
  String get moduleName => 'auth';

  @override
  void registerDependencies(GetIt locator, AppConfig appConfig) {
    // Register secure storage
    locator.registerLazySingleton<FlutterSecureStorage>(
      () => const FlutterSecureStorage(),
    );

    // Register auth service
    locator.registerLazySingleton<AuthService>(
      () => AuthService(
        dio: locator.get(),
        baseUrl: appConfig.apiBaseUrl,
      ),
    );

    // Register auth repository
    locator.registerLazySingleton<AuthRepository>(
      () => AuthRepositoryImpl(
        locator.get<AuthService>(),
        locator.get<FlutterSecureStorage>(),
      ),
    );
  }
}

// lib/modules/auth/auth_router.dart
import 'package:go_router/go_router.dart';
import 'package:modular_core/modular_core.dart';
import 'screens/login_screen.dart';
import 'screens/register_screen.dart';
import 'screens/forgot_password_screen.dart';

class AuthRouter extends ModuleRouter {
  @override
  String get basePath => '/auth';

  @override
  List<RouteBase> get routes => [
    GoRoute(
      path: '$basePath/login',
      name: 'login',
      builder: (context, state) {
        final redirectPath = state.uri.queryParameters['redirect'];
        return LoginScreen(redirectPath: redirectPath);
      },
    ),
    GoRoute(
      path: '$basePath/register',
      name: 'register',
      builder: (context, state) => const RegisterScreen(),
    ),
    GoRoute(
      path: '$basePath/forgot-password',
      name: 'forgot-password',
      builder: (context, state) => const ForgotPasswordScreen(),
    ),
  ];
}
```

## Usage

### Global Auth Guard

```dart
// lib/core/auth_guard.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import '../modules/auth/providers/auth_providers.dart';

class AuthGuard {
  static String? checkAuth(GoRouterState state, WidgetRef ref) {
    final isAuthenticated = ref.read(isAuthenticatedProvider);
    final isAuthRoute = state.uri.path.startsWith('/auth');

    if (!isAuthenticated && !isAuthRoute) {
      return '/auth/login?redirect=${state.uri.toString()}';
    }

    if (isAuthenticated && isAuthRoute) {
      return '/dashboard';
    }

    return null;
  }
}
```

### App Router with Auth

```dart
// lib/core/app_router.dart
class AppRouter {
  static GoRouter createRouter(WidgetRef ref) {
    return GoRouter(
      redirect: (context, state) => AuthGuard.checkAuth(state, ref),
      routes: [
        // Auth routes
        ...AuthModule().routes,

        // Protected routes
        GoRoute(
          path: '/dashboard',
          builder: (context, state) => const DashboardScreen(),
          redirect: (context, state) {
            final isAuthenticated = ref.read(isAuthenticatedProvider);
            return isAuthenticated ? null : '/auth/login';
          },
        ),
      ],
    );
  }
}
```

## Testing

### Unit Tests

```dart
void main() {
  group('LoginViewModel', () {
    late MockAuthRepository mockRepository;
    late LoginViewModel viewModel;

    setUp(() {
      mockRepository = MockAuthRepository();
      viewModel = LoginViewModel(mockRepository);
    });

    test('should validate email format', () {
      viewModel.updateEmail('invalid-email');
      expect(viewModel.state.emailError, isNotNull);

      viewModel.updateEmail('valid@email.com');
      expect(viewModel.state.emailError, isNull);
    });

    test('should login successfully', () async {
      // Arrange
      viewModel.updateEmail('test@example.com');
      viewModel.updatePassword('password123');

      when(mockRepository.login(any)).thenAnswer((_) async =>
        const AuthState(isAuthenticated: true));

      // Act
      await viewModel.login();

      // Assert
      expect(viewModel.state.status, UiStatus.success);
      verify(mockRepository.login(any)).called(1);
    });
  });
}
```

## Best Practices

### 1. Secure Token Storage

- Use `flutter_secure_storage` for sensitive data
- Implement token refresh logic
- Clear tokens on logout

### 2. Error Handling

- Provide specific error messages
- Handle network timeouts
- Implement retry mechanisms

### 3. User Experience

- Show loading states
- Validate input in real-time
- Remember user preferences

### 4. Security

- Validate tokens on app start
- Implement automatic logout on token expiry
- Use HTTPS for all auth requests

This authentication module provides a complete, production-ready implementation that can be easily integrated into any Modular Flutter application.
